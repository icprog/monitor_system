C51 COMPILER V9.01   S6B3306                                                               01/03/2014 13:18:32 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE S6B3306
OBJECT MODULE PLACED IN .\out\s6b3306.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\s6b3306.c BROWSE DEBUG OBJECTEXTEND PRINT(.\s6b3306.lst) OBJECT(.\out\s
                    -6b3306.obj)

line level    source

   1          #include "s6b3306.h"
   2          #include "LZF5162.h"
   3          
   4          #include "zi16.h"
   5          
   6          
   7          //---------------------------------------------------------3线SPI接口 驱动
   8          //&&&&&&&&&&&&&&&&&&&&&&&&&&&         PS=0;MPU=0   &&&&&&&&&&&&&&&&&&
   9                             
  10          sbit    RSTB = P1^5;
  11          sbit    SCL  = P1^4;
  12          sbit    SDI  = P1^2;
  13          sbit    CS1  = P1^0;
  14          
  15          
  16          
  17           
  18          
  19          
  20          
  21          //--------------------------------------------------------------------------
  22          // 初始化S6B3306 2013-12-21 LIZHF
  23          // 开机-复位-关闭待机-200mS-设置寄存器-100mS-开始显示
  24          //
  25          //--------------------------------------------------------------------------
  26          void Init_S6B33B()
  27          {
  28   1             HDReset();
  29   1             delay_1ms(50);
  30   1             Write_S6B33B_COM(0x2c);  //关闭待机模式
  31   1             delay_1ms(240);                  
  32   1            // Write_S6B33B_COM(0x02);        //设置振荡模式
  33   1            // Write_S6B33B_COM(0x00);  //设置00:内部振荡  默认也是内部振荡
  34   1      
  35   1             Write_S6B33B_COM(0x28);  //设置温度斜率补偿   
  36   1             Write_S6B33B_COM(0x01);  //01：-0.05%/°C 
  37   1      
  38   1            // Write_S6B33B_COM(0x45);    //RAM Skip AREA set设置显示RAM数据的X地址区域
  39   1            // Write_S6B33B_COM(0x00);          //不跳动      默认00
  40   1            // Write_S6B33B_COM(0x53);    //指定显示模式  
  41   1            // Write_S6B33B_COM(0x00);          //00：一般模式 默认00
  42   1             Write_S6B33B_COM(0x10);    //Drive output mode set
  43   1             Write_S6B33B_COM(0x03+0X8);    //22    0,0,DLN,MY,MX,SWP,CDIR 行列增量正负(MY MX)=0
  44   1                                            //修改为默认00 给的03
  45   1      
  46   1             Write_S6B33B_COM(0x30);  //4k he 65k 
  47   1             Write_S6B33B_COM(0x1d);  //1d  //修改为默认00
  48   1             Write_S6B33B_COM(0x32);  //设置行功能 Row vector mode set
  49   1             Write_S6B33B_COM(0x0e);  //      行增量于每周期 默认00每组0E每帧
  50   1             Write_S6B33B_COM(0x40);  //输入模式
  51   1             Write_S6B33B_COM(0x80+0X02);  //00  Y/X=0
  52   1             Write_S6B33B_COM(0x42);  // Y ADDRESS 
  53   1             Write_S6B33B_COM(2);
  54   1             Write_S6B33B_COM(129);
C51 COMPILER V9.01   S6B3306                                                               01/03/2014 13:18:32 PAGE 2   

  55   1             Write_S6B33B_COM(0x43); // X ADDRESS
  56   1             Write_S6B33B_COM(4);
  57   1             Write_S6B33B_COM(131);
  58   1             Write_S6B33B_COM(0x34);  //反转设置 
  59   1             Write_S6B33B_COM(0x8d);   //修改为默认00不反转，原8D
  60   1             Write_S6B33B_COM(0x2a);  // 调节对比度值 
  61   1             Write_S6B33B_COM(0x32);   //V1 3.339V  默认00 2.8V最大7F 4V
  62   1             Write_S6B33B_COM(0x55);   //局部显示模式设置   
  63   1             Write_S6B33B_COM(0x00);   //局部显示开关。00关 01开
  64   1             Write_S6B33B_COM(0x56);   //局部显示开始的LINE地址（Y地址？）
  65   1             Write_S6B33B_COM(0x00);
  66   1             Write_S6B33B_COM(0x57);   //局部显示结束的LINE地址（Y地址？）  
  67   1             Write_S6B33B_COM(0x9f);
  68   1                 delay_1ms(120);;
  69   1             Write_S6B33B_COM(0x51);  //Display ON
  70   1      }
  71          
  72          //***************************************************************************SPI3
  73          void Write_S6B33B_COM(uint8_t COMDADA_3SPI)
  74          {
  75   1       uint8_t bit8;
  76   1       CS1=0;
  77   1       SCL=0;
  78   1       SDI=0;
  79   1       SCL=1; 
  80   1       for(bit8=0;bit8<8;bit8++)
  81   1       {
  82   2        SCL=0;
  83   2        SDI=COMDADA_3SPI&0x80;
  84   2        SCL=1;
  85   2        COMDADA_3SPI=(COMDADA_3SPI<<1);
  86   2       }
  87   1          CS1=1;
  88   1         
  89   1      }
  90          void Write_S6B33B_DISPLAY_DATA_serial_3SPI(uint8_t DADA_3SPI)
  91          {   
  92   1       uint8_t bit8;
  93   1       CS1=0;
  94   1       SCL=0;
  95   1       SDI=1;
  96   1       SCL=1;
  97   1       for(bit8=0;bit8<8;bit8++)
  98   1       {
  99   2        SCL=0;
 100   2        SDI=DADA_3SPI&0x80;
 101   2        SCL=1;
 102   2        DADA_3SPI=(DADA_3SPI<<1);
 103   2       }
 104   1        CS1=1;
 105   1      }
 106          void Write_S6B33B_DISPLAY_DATA(uint8_t hibyte,uint8_t lowbyte)
 107          {
 108   1       Write_S6B33B_DISPLAY_DATA_serial_3SPI(hibyte);
 109   1       Write_S6B33B_DISPLAY_DATA_serial_3SPI(lowbyte);
 110   1      }
 111            
 112          
 113          
 114          /*************************************************************
 115          // S6B3306复位 2013-12-21 LIZHF
 116          // 上电-2mS-复位-等待释放复位.
C51 COMPILER V9.01   S6B3306                                                               01/03/2014 13:18:32 PAGE 3   

 117          //
 118          *************************************************************/
 119          void HDReset()
 120          {
 121   1       delay_1ms(5);
 122   1       RSTB=0;
 123   1       delay_1ms(20);
 124   1       RSTB=1;
 125   1       delay_1ms(20);
 126   1      
 127   1      }
 128          
 129          //--------------------------------------------------------
 130          // 设置要显示区域的地址:X,Y为起始地址 ix,iy为增量地址
 131          //
 132          //
 133          //--------------------------------------------------------
 134          void setad(uint8_t x,uint8_t ix,uint8_t y,uint8_t iy)
 135          {
 136   1           Write_S6B33B_COM(0x42);  // Y ADDRESS 
 137   1           Write_S6B33B_COM(2+x);
 138   1           Write_S6B33B_COM(2+x+ix);
 139   1           Write_S6B33B_COM(0x43); // X ADDRESS
 140   1           Write_S6B33B_COM(4+y);
 141   1           Write_S6B33B_COM(4+y+iy);
 142   1               delay_1ms(1);
 143   1      } 
 144          
 145            
 146          /*************************************************************
 147          // S6B3306测试 2013-12-21 LIZHF
 148          //  
 149          //
 150          *************************************************************/ 
 151          /*
 152          void test_s6b3306()
 153          { 
 154           uint8_t p,q;
 155           delay_1ms(100); 
 156           Init_S6B33B();
 157           //0xf8,0x00单色
 158           setad(0,127,0,127);
 159           for(p=0;p<128;p++)
 160           {
 161            for(q=0;q<128;q++)
 162              Write_S6B33B_DISPLAY_DATA(0xf8,0x00);
 163           }
 164          delay_1ms(1000); 
 165          
 166          //0x07,0xe0单色
 167          setad(0,127,0,127);
 168          for(p=0;p<128;p++)
 169           {
 170            for(q=0;q<128;q++)
 171             Write_S6B33B_DISPLAY_DATA(0x07,0xe0);
 172           }
 173          delay_1ms(1000); 
 174           
 175          //0x00,0x1f单色
 176          setad(0,127,0,127);
 177           for(p=0;p<128;p++)
 178           {
C51 COMPILER V9.01   S6B3306                                                               01/03/2014 13:18:32 PAGE 4   

 179            for(q=0;q<128;q++)
 180            {
 181             Write_S6B33B_DISPLAY_DATA(0x00,0x1f);
 182            }
 183           }
 184          delay_1ms(1000); 
 185          
 186          
 187          // 七色条码
 188          setad(0,127,0,127);
 189           for(p=0;p<128;p++)
 190           {
 191            for(q=0;q<16;q++)
 192            {
 193             Write_S6B33B_DISPLAY_DATA(0xf8,0x00);
 194            }
 195            for(q=0;q<16;q++)
 196            {
 197             Write_S6B33B_DISPLAY_DATA(0x07,0xe0);
 198            }
 199            for(q=0;q<16;q++)
 200            {
 201             Write_S6B33B_DISPLAY_DATA(0x00,0x1f);
 202            }
 203            for(q=0;q<16;q++)
 204            {
 205             Write_S6B33B_DISPLAY_DATA(0xff,0xff);
 206             }
 207            for(q=0;q<16;q++)
 208            {
 209             Write_S6B33B_DISPLAY_DATA(0x00,0x00);
 210            }
 211            for(q=0;q<16;q++)
 212            {
 213             Write_S6B33B_DISPLAY_DATA(0x00,0x1f);
 214            }  
 215            for(q=0;q<16;q++)
 216            {
 217             Write_S6B33B_DISPLAY_DATA(0x07,0xe0);
 218            }
 219            for(q=0;q<16;q++)
 220            {
 221             Write_S6B33B_DISPLAY_DATA(0xf8,0x00);
 222            }
 223           }
 224          
 225          } */
 226                  
 227          /***************************************************************************************
 228           描述: 在以X Y 起始的位置输入一个16X16大小的字
 229                     蓝底白字
 230          
 231          ****************************************************************************************/
 232          void zi16(uint8_t x,uint8_t y,const unsigned char *p)
 233          {   uint8_t QQ,px,ax;
 234   1          setad(x,15,y,15);
 235   1                 QQ=0;
 236   1             for(px=0;px<32;px++)     //一个字72个字节 每个字节8个位
 237   1                  { ax = p[px];
 238   2                for(QQ=0;QQ<8;QQ++)  //处理8个位，是1就出颜色 否则出0XFF 0XFF（黑色）
 239   2                        {     
 240   3                               if(ax&0x80)
C51 COMPILER V9.01   S6B3306                                                               01/03/2014 13:18:32 PAGE 5   

 241   3                   Write_S6B33B_DISPLAY_DATA(0Xff,0X0ff);           //高位是1写入红色
 242   3                       else   Write_S6B33B_DISPLAY_DATA(0X0,0X1f);          //高位是1写入颜色             
 243   3                   ax=(ax<<1);         //左移  
 244   3                              
 245   3                        }
 246   2              }
 247   1      }
 248          
 249          /***************************************************************************************
 250           描述: 在以X Y 起始的位置输入一个16X16大小的字
 251                     白底蓝字
 252          
 253          ****************************************************************************************/
 254          void fzi16(uint8_t x,uint8_t y,const unsigned char *p)
 255          {   uint8_t QQ,px,ax;
 256   1          setad(x,15,y,15);
 257   1                 QQ=0;
 258   1             for(px=0;px<32;px++)     //一个字72个字节 每个字节8个位
 259   1                  { ax = p[px];
 260   2                for(QQ=0;QQ<8;QQ++)  //处理8个位，是1就出颜色 否则出0XFF 0XFF（黑色）
 261   2                        {     
 262   3                               if(ax&0x80)
 263   3                   Write_S6B33B_DISPLAY_DATA(0X00,0X1f);            //高位是1写入红色
 264   3                       else   Write_S6B33B_DISPLAY_DATA(0Xff,0Xff);         //高位是1写入白色             
 265   3                   ax=(ax<<1);         //左移  
 266   3                              
 267   3                        }
 268   2              }
 269   1      }
 270          
 271          /***************************************************************************************
 272           描述: 在以X Y 起始的位置输入一个8X16大小的字
 273                 蓝底白字
 274          
 275          ****************************************************************************************/
 276          void zi8(uint8_t x,uint8_t y,const unsigned char *p)
 277          {   uint8_t QQ,px,ax;
 278   1          setad(x,7,y,15);
 279   1                 QQ=0;
 280   1             for(px=0;px<16;px++)     //一个字72个字节 每个字节8个位
 281   1                  { ax = p[px];
 282   2                for(QQ=0;QQ<8;QQ++)  //处理8个位，是1就出颜色  
 283   2                        {     
 284   3                               if(ax&0x80)
 285   3                   Write_S6B33B_DISPLAY_DATA(0Xff,0X0ff);           //高位是1写入红色
 286   3                       else   Write_S6B33B_DISPLAY_DATA(0X0,0X1f);          //高位是1写入颜色             
 287   3                   ax=(ax<<1);         //左移  
 288   3                              
 289   3                        }
 290   2              }
 291   1      }
 292          
 293          /***************************************************************************************
 294           描述: 在以X Y 起始的位置输入一个8X16大小的字
 295                     白底蓝字
 296          
 297          
 298          void fzi8(uint8_t x,uint8_t y,const unsigned char *p)
 299          {   uint8_t QQ,px,ax;
 300              setad(x,7,y,15);
 301                     QQ=0;
 302                 for(px=0;px<16;px++)     //一个字72个字节 每个字节8个位
C51 COMPILER V9.01   S6B3306                                                               01/03/2014 13:18:32 PAGE 6   

 303                      { ax = p[px];
 304                    for(QQ=0;QQ<8;QQ++)  //处理8个位，是1就出颜色  
 305                            {     
 306                                   if(ax&0x80)
 307                       Write_S6B33B_DISPLAY_DATA(0X00,0X01f);           //高位是1写入蓝色
 308                           else   Write_S6B33B_DISPLAY_DATA(0X0ff,0Xff);        //高位是1写入白色             
 309                       ax=(ax<<1);         //左移  
 310                                  
 311                            }
 312                  }
 313          }
 314          ****************************************************************************************/
 315          
 316                   
 317          /***************************************************************************************
 318           描述:  将背景改成纯蓝色 
 319          
 320          ****************************************************************************************/
 321          void BIUE(void)
 322          {
 323   1          uint8_t p,q;
 324   1      
 325   1          setad(0,127,0,127);
 326   1         
 327   1          for(p=0;p<128;p++)
 328   1          {
 329   2            for(q=0;q<128;q++)     
 330   2               Write_S6B33B_DISPLAY_DATA(0x00,0x1f);   
 331   2          }
 332   1      
 333   1      }
 334          
 335          
 336           /*
 337          void logo(void)
 338          {
 339                  uint8_t p,q,QQ;
 340              setad(0,127,0,127);
 341                     QQ=0;
 342                  for(p=0;p<128;p++)
 343                  {
 344                          for(q=0;q<128;q++)
 345                          {
 346                                  Write_S6B33B_DISPLAY_DATA(QQ,QQ+1);
 347                                  QQ++;
 348                                  QQ++;
 349                          }
 350                  }
 351          
 352          
 353          }        */
 354          /***************************************************************************************
 355           描述: 预显示的菜单
 356          
 357          
 358          ****************************************************************************************/
 359          void yu()
 360          {
 361   1      
 362   1        zi16(16,0,hzli);
 363   1        zi16(32,0,hzdian);
 364   1        zi16(48,0,hzrong);
C51 COMPILER V9.01   S6B3306                                                               01/03/2014 13:18:32 PAGE 7   

 365   1        zi16(64,0,hzliang);
 366   1        zi16(80,0,hzce);
 367   1        zi16(96,0,hzshi);
 368   1        //设置:
 369   1        zi16(0,16,hzshe);
 370   1        zi16(16,16,hzzhi);
 371   1        zi8(32,16,fhmh);
 372   1        //放电电流:
 373   1           //放电电流:
 374   1         zi16(0,32,hzfang);
 375   1         zi16(16,32,hzdian);
 376   1         zi16(32,32,hzdian);
 377   1         zi16(48,32,hzliu);
 378   1      
 379   1         zi8(64,32,fhmh);  
 380   1         zi8(88,32,fhd);
 381   1         zi8(104,32,zmA);
 382   1         //结束电压:
 383   1                //结束电压:
 384   1         zi16(0,48,hzjie);
 385   1         zi16(16,48,hzshu);
 386   1         zi16(32,48,hzdian);
 387   1         zi16(48,48,hzya); 
 388   1         zi8(64,48,fhmh);
 389   1         zi8(88,48,fhd);
 390   1         zi8(104,48,zmV);
 391   1      
 392   1        //状态:
 393   1        zi16(0,64,hzzhun);
 394   1        zi16(16,64,hztai);
 395   1        zi8(32,64,fhmh);
 396   1        //放电电流:
 397   1        zi16(0,80,hzfang);
 398   1        zi16(16,80,hzdian);
 399   1        zi16(32,80,hzdian);
 400   1        zi16(48,80,hzliu);
 401   1        zi8(64,80,fhmh);
 402   1        zi8(80,80,fhd);
 403   1        zi8(104,80,zmA);
 404   1        //电池电压:
 405   1        zi16(0,96,hzdian);
 406   1        zi16(16,96,hzchi);
 407   1        zi16(32,96,hzdian);
 408   1        zi16(48,96,hzya);
 409   1        zi8(64,96,fhmh);
 410   1        zi8(80,96,fhd);
 411   1        zi8(104,96,zmV);
 412   1        //已放容量:
 413   1        zi16(0,112,hzyi);
 414   1        zi16(16,112,hzfang);
 415   1        zi16(32,112,hzrong);
 416   1        zi16(48,112,hzliang);
 417   1        zi8(64,112,fhmh);
 418   1        zi8(104,112,zmm);
 419   1        zi8(112,112,zmA);
 420   1        zi8(120,112,zmH);
 421   1      
 422   1      }
 423          
 424          
 425          /***************************************************************************************
 426           描述:状态
C51 COMPILER V9.01   S6B3306                                                               01/03/2014 13:18:32 PAGE 8   

 427           输入:xa,ADC的50次平均值.xv,ADC50次的平均值 mah电池容量的结果
 428          
 429          ****************************************************************************************/
 430          
 431          void xs_zt(uint16_t xa,uint16_t xv,uint16_t mah)
 432          {
 433   1        uint8_t a13,a12,a10,v13,v12,v10;
 434   1        uint8_t  m14,m13,m12,m11,m1;
 435   1         
 436   1        //电流
 437   1        xa = xa*2.32;
 438   1        if(xa%10>7)
 439   1         xa= xa+10;
 440   1      
 441   1        a13 = xa/1000;
 442   1        a12 = (xa%1000)/100;
 443   1        a10 = (xa%100)/10;
 444   1       // a1 = xa%10;
 445   1       
 446   1        zi8(72,80,sn[a13]);
 447   1        //zi8(80,80,sn[a100]);
 448   1        zi8(88,80,sn[a12]);
 449   1        zi8(96,80,sn[a10]);
 450   1        //电压
 451   1        xv = xv*4.87;
 452   1        if(xa%10>7)
 453   1        xv = xv+10;
 454   1      
 455   1        v13 = xv/1000;
 456   1        v12 = (xv%1000)/100;
 457   1        v10 = (xv%100)/10;
 458   1        //v1 = xv%10;
 459   1       
 460   1        zi8(72,96,sn[v13]);
 461   1       // zi8(80,96,sn[v100]);
 462   1        zi8(88,96,sn[v12]);
 463   1        zi8(96,96,sn[v10]); 
 464   1        //容量
 465   1        m14 = mah/10000;
 466   1        m13 = (mah%10000)/1000;
 467   1        m12 = (mah%1000)/100;
 468   1        m11 = (mah%100)/10;
 469   1        m1 = mah%10;
 470   1        if(m14>0)
 471   1        { 
 472   2          zi8(72,112,sn[m14]);
 473   2              zi8(80,112,sn[m13]);
 474   2              zi8(88,112,fhd);
 475   2              zi8(96,112,sn[m12]);
 476   2              zi8(104,112,sn[m11]);
 477   2              }
 478   1              else
 479   1              {
 480   2              zi8(72,112,sn[m13]);
 481   2              zi8(80,112,sn[m12]);
 482   2              zi8(88,112,sn[m11]);
 483   2              zi8(96,112,sn[m1]);
 484   2              zi8(104,112,zmm);       
 485   2              }
 486   1      
 487   1      
 488   1      }
C51 COMPILER V9.01   S6B3306                                                               01/03/2014 13:18:32 PAGE 9   

 489          /***************************************************************************************
 490           描述: 预设的值显示, seta,setv
 491                 引入变量setn,0 
 492                                  1:"设置电流" 
 493                                              2:"结束电压"
 494                          fdzt:0显示停止中
 495                               1显示放电中
 496          ****************************************************************************************/
 497          void xs_sz(uint8_t seta,uint8_t setv,uint8_t setn)
 498          {
 499   1        uint8_t a10,a1,v10,v1; 
 500   1        a10 = (seta%100)/10;
 501   1        a1 = seta%10;
 502   1        v10 = (setv%100)/10;
 503   1        v1 = setv%10;  
 504   1      
 505   1        //: 2.0A  
 506   1        zi8(80,32,sn[a10]);  
 507   1        zi8(96,32,sn[a1]);
 508   1        
 509   1         //: 3.2V       
 510   1        zi8(80,48,sn[v10]);  
 511   1        zi8(96,48,sn[v1]);
 512   1        
 513   1          if(setn == 0)
 514   1        {  
 515   2             //放电电流:
 516   2         zi16(0,32,hzfang);
 517   2         zi16(16,32,hzdian);
 518   2         zi16(32,32,hzdian);
 519   2         zi16(48,32,hzliu);
 520   2                //结束电压:
 521   2         zi16(0,48,hzjie);
 522   2         zi16(16,48,hzshu);
 523   2         zi16(32,48,hzdian);
 524   2         zi16(48,48,hzya);
 525   2      
 526   2        }
 527   1          if(setn == 1)
 528   1        {   
 529   2             //放电电流:
 530   2         fzi16(0,32,hzfang);
 531   2         fzi16(16,32,hzdian);
 532   2         fzi16(32,32,hzdian);
 533   2         fzi16(48,32,hzliu);
 534   2                //结束电压:
 535   2         zi16(0,48,hzjie);
 536   2         zi16(16,48,hzshu);
 537   2         zi16(32,48,hzdian);
 538   2         zi16(48,48,hzya);
 539   2         // zi8(112,32,fhjt);
 540   2       
 541   2       
 542   2        }
 543   1         if(setn == 2)
 544   1        {    //放电电流:
 545   2         zi16(0,32,hzfang);
 546   2         zi16(16,32,hzdian);
 547   2         zi16(32,32,hzdian);
 548   2         zi16(48,32,hzliu);
 549   2                //结束电压:
 550   2         fzi16(0,48,hzjie);
C51 COMPILER V9.01   S6B3306                                                               01/03/2014 13:18:32 PAGE 10  

 551   2         fzi16(16,48,hzshu);
 552   2         fzi16(32,48,hzdian);
 553   2         fzi16(48,48,hzya);
 554   2        // zi8(112,48,fhjt);  
 555   2        }
 556   1      
 557   1      
 558   1      }
 559          void xsfdzt(bit fdzt)
 560          {
 561   1        if(fdzt)
 562   1         {
 563   2          zi16(40,64,hzfang); 
 564   2          zi16(56,64,hzdian);
 565   2          zi16(72,64,hzzhong);  
 566   2         }
 567   1        else
 568   1         {
 569   2              zi16(40,64,hzting); 
 570   2          zi16(56,64,hzzi);
 571   2         }
 572   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2334    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      31
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
